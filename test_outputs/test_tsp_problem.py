"""
DEAP Evolutionary Algorithm
Generated by EVOC DEAP Agent

This script combines all 12 cells into a single executable file.
"""


# ======================================================================
# Cell 0: imports
# ======================================================================

import random
import numpy as np
import matplotlib.pyplot as plt
from deap import base, creator, tools, algorithms

# ======================================================================
# Cell 1: config
# ======================================================================

# Configuration constants
DIMENSIONS = 20  # number of cities
LOWER_BOUND = 0.0
UPPER_BOUND = 19.0
POP_SIZE = 100
N_GEN = 50
CX_PROB = 0.7
MUT_PROB = 0.2
TOURN_SIZE = 3
SEED = 42

random.seed(SEED)
np.random.seed(SEED)

# Generate random coordinates for the cities
city_coords = np.random.rand(DIMENSIONS, 2) * 100  # 100x100 area

# Pre‑compute Euclidean distance matrix
dist_matrix = np.sqrt(((city_coords[:, None, :] - city_coords[None, :, :]) ** 2).sum(axis=2))

# ======================================================================
# Cell 2: creator
# ======================================================================

# DEAP creator – define fitness and individual classes
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# ======================================================================
# Cell 3: evaluate
# ======================================================================

def evaluate(individual):
    """Convert random‑key representation to a permutation and compute total tour length."""
    # Random‑key to permutation
    permutation = np.argsort(individual).astype(int)
    # Calculate tour length (return to start)
    tour_length = 0.0
    for i in range(DIMENSIONS):
        a = permutation[i]
        b = permutation[(i + 1) % DIMENSIONS]
        tour_length += dist_matrix[a, b]
    return (tour_length,)

# ======================================================================
# Cell 4: crossover
# ======================================================================

def mate(ind1, ind2):
    """Blend crossover (cxBlend) for random‑key vectors."""
    return tools.cxBlend(ind1, ind2, alpha=0.5)

# ======================================================================
# Cell 5: mutation
# ======================================================================

def mutate(individual):
    """Gaussian mutation for random‑key vectors."""
    tools.mutGaussian(individual, mu=0.0, sigma=1.0, indpb=0.2)
    # Keep keys inside the allowed bounds
    for i, val in enumerate(individual):
        if val < LOWER_BOUND:
            individual[i] = LOWER_BOUND
        elif val > UPPER_BOUND:
            individual[i] = UPPER_BOUND
    return (individual,)

# ======================================================================
# Cell 6: selection
# ======================================================================

def select(population, k):
    """Tournament selection."""
    return tools.selTournament(population, k, tournsize=TOURN_SIZE)

# ======================================================================
# Cell 7: additional_operators
# ======================================================================

# Additional helper: clip function (used in mutation above)

def clip(individual):
    """Force all genes to stay within [LOWER_BOUND, UPPER_BOUND]."""
    for i, val in enumerate(individual):
        individual[i] = max(min(val, UPPER_BOUND), LOWER_BOUND)
    return individual

# ======================================================================
# Cell 8: initialization
# ======================================================================

def create_individual():
    """Create a random‑key individual."""
    return [random.uniform(LOWER_BOUND, UPPER_BOUND) for _ in range(DIMENSIONS)]

# ======================================================================
# Cell 9: toolbox_registration
# ======================================================================

toolbox = base.Toolbox()
toolbox.register("individual", tools.initIterate, creator.Individual, create_individual)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

toolbox.register("evaluate", evaluate)
toolbox.register("mate", mate)
toolbox.register("mutate", mutate)
toolbox.register("select", select)

# Statistics to track
stats = tools.Statistics(lambda ind: ind.fitness.values)
stats.register("min", np.min)
stats.register("avg", np.mean)

halloffame = tools.HallOfFame(1)

# ======================================================================
# Cell 10: evolution_loop
# ======================================================================

def main():
    pop = toolbox.population(n=POP_SIZE)
    # Evaluate the initial population
    fitnesses = list(map(toolbox.evaluate, pop))
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit

    # Evolutionary loop
    for gen in range(1, N_GEN + 1):
        # Select the next generation individuals
        offspring = toolbox.select(pop, len(pop))
        offspring = list(map(toolbox.clone, offspring))

        # Apply crossover and mutation
        for child1, child2 in zip(offspring[::2], offspring[1::2]):
            if random.random() < CX_PROB:
                toolbox.mate(child1, child2)
                del child1.fitness.values
                del child2.fitness.values

        for mutant in offspring:
            if random.random() < MUT_PROB:
                toolbox.mutate(mutant)
                del mutant.fitness.values

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        # Replace population
        pop[:] = offspring

        # Update hall of fame and statistics
        halloffame.update(pop)
        record = stats.compile(pop)
        print(f"Gen {gen}: Min {record['min']:.2f} Avg {record['avg']:.2f}")

    return pop, halloffame, stats

pop, hof, log = main()

# ======================================================================
# Cell 11: results_and_plots
# ======================================================================

# Best individual (random‑key) and its permutation
best_ind = hof[0]
best_perm = np.argsort(best_ind).astype(int)
best_distance = evaluate(best_ind)[0]

print("\nBest tour length:", best_distance)
print("Best permutation:", best_perm)

# Plot the best tour if visualization is requested
if True:
    plt.figure(figsize=(8, 6))
    tour_coords = city_coords[best_perm]
    # Close the loop
    tour_coords = np.vstack([tour_coords, tour_coords[0]])
    plt.plot(tour_coords[:, 0], tour_coords[:, 1], marker='o')
    plt.title(f"Best TSP Tour – Length {best_distance:.2f}")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.grid(True)
    plt.show()